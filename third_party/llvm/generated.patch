Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/lib/Basic/Targets/SPIR.h b/clang/lib/Basic/Targets/SPIR.h
--- a/clang/lib/Basic/Targets/SPIR.h
+++ b/clang/lib/Basic/Targets/SPIR.h
@@ -58,8 +58,9 @@
 // Used by both the SPIR and SPIR-V targets.
 static const unsigned SPIRDefIsGenMap[] = {
     4, // Default
-    // OpenCL address space values for this map are dummy and they can't be used
-    0, // opencl_global
+    // Some OpenCL address space values for this map are dummy and they can't be
+    // used
+    1, // opencl_global
     0, // opencl_local
     0, // opencl_constant
     0, // opencl_private
diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReaderDecl.cpp b/clang/lib/Serialization/ASTReaderDecl.cpp
--- a/clang/lib/Serialization/ASTReaderDecl.cpp
+++ b/clang/lib/Serialization/ASTReaderDecl.cpp
@@ -1076,6 +1076,8 @@
   FD->setFriendConstraintRefersToEnclosingTemplate(
       FunctionDeclBits.getNextBit());
   FD->setUsesSEHTry(FunctionDeclBits.getNextBit());
+  FD->setIsDestroyingOperatorDelete(FunctionDeclBits.getNextBit());
+  FD->setIsTypeAwareOperatorNewOrDelete(FunctionDeclBits.getNextBit());
 
   FD->EndRangeLoc = readSourceLocation();
   if (FD->isExplicitlyDefaulted())
diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTWriterDecl.cpp b/clang/lib/Serialization/ASTWriterDecl.cpp
--- a/clang/lib/Serialization/ASTWriterDecl.cpp
+++ b/clang/lib/Serialization/ASTWriterDecl.cpp
@@ -847,6 +847,8 @@
   FunctionDeclBits.addBit(D->isInstantiatedFromMemberTemplate());
   FunctionDeclBits.addBit(D->FriendConstraintRefersToEnclosingTemplate());
   FunctionDeclBits.addBit(D->usesSEHTry());
+  FunctionDeclBits.addBit(D->isDestroyingOperatorDelete());
+  FunctionDeclBits.addBit(D->isTypeAwareOperatorNewOrDelete());
   Record.push_back(FunctionDeclBits);
 
   Record.AddSourceLocation(D->getEndLoc());
diff -ruN --strip-trailing-cr a/clang/test/CodeGenCUDASPIRV/printf.cu b/clang/test/CodeGenCUDASPIRV/printf.cu
--- a/clang/test/CodeGenCUDASPIRV/printf.cu
+++ b/clang/test/CodeGenCUDASPIRV/printf.cu
@@ -0,0 +1,11 @@
+// RUN: %clang_cc1 -fcuda-is-device -triple spirv32 -o - -emit-llvm -x cuda %s  | FileCheck --check-prefix=CHECK-SPIRV32 %s
+// RUN: %clang_cc1 -fcuda-is-device -triple spirv64 -o - -emit-llvm -x cuda %s  | FileCheck --check-prefix=CHECK-SPIRV64 %s
+
+// CHECK-SPIRV32: @.str = private unnamed_addr addrspace(4) constant [13 x i8] c"Hello World\0A\00", align 1
+// CHECK-SPIRV64: @.str = private unnamed_addr addrspace(1) constant [13 x i8] c"Hello World\0A\00", align 1
+
+extern "C" __attribute__((device)) int printf(const char* format, ...);
+
+__attribute__((global)) void printf_kernel() {
+  printf("Hello World\n");
+}
diff -ruN --strip-trailing-cr a/clang/test/Modules/Inputs/PR137102/module.modulemap b/clang/test/Modules/Inputs/PR137102/module.modulemap
--- a/clang/test/Modules/Inputs/PR137102/module.modulemap
+++ b/clang/test/Modules/Inputs/PR137102/module.modulemap
@@ -0,0 +1 @@
+module type_aware_destroying_new_delete { header "type_aware_destroying_new_delete.h" export * }
diff -ruN --strip-trailing-cr a/clang/test/Modules/Inputs/PR137102/type_aware_destroying_new_delete.h b/clang/test/Modules/Inputs/PR137102/type_aware_destroying_new_delete.h
--- a/clang/test/Modules/Inputs/PR137102/type_aware_destroying_new_delete.h
+++ b/clang/test/Modules/Inputs/PR137102/type_aware_destroying_new_delete.h
@@ -0,0 +1,52 @@
+
+namespace std {
+    struct destroying_delete_t { };
+    template <class T> struct type_identity {
+        using type = T;
+    };
+    typedef __SIZE_TYPE__ size_t;
+    enum class align_val_t : size_t;
+};
+
+struct A {
+    A();
+   void *operator new(std::size_t);
+   void operator delete(A*, std::destroying_delete_t);
+};
+
+struct B {
+    B();
+    void *operator new(std::type_identity<B>, std::size_t, std::align_val_t);
+    void operator delete(std::type_identity<B>, void*, std::size_t, std::align_val_t);
+};
+
+struct C {
+    C();
+    template <class T> void *operator new(std::type_identity<T>, std::size_t, std::align_val_t);
+    template <class T> void operator delete(std::type_identity<T>, void*, std::size_t, std::align_val_t);
+};
+
+struct D {
+    D();
+};
+void *operator new(std::type_identity<D>, std::size_t, std::align_val_t);
+void operator delete(std::type_identity<D>, void*, std::size_t, std::align_val_t);
+
+struct E {
+    E();
+};
+template <class T> void *operator new(std::type_identity<T>, std::size_t, std::align_val_t);
+template <class T> void operator delete(std::type_identity<T>, void*, std::size_t, std::align_val_t);
+
+void in_module_tests() {
+  A* a = new A;
+  delete a;
+  B *b = new B;
+  delete b;
+  C *c = new C;
+  delete c;
+  D *d = new D;
+  delete d;
+  E *e = new E;
+  delete e;
+}
diff -ruN --strip-trailing-cr a/clang/test/Modules/type-aware-destroying-new-and-delete-modules.cpp b/clang/test/Modules/type-aware-destroying-new-and-delete-modules.cpp
--- a/clang/test/Modules/type-aware-destroying-new-and-delete-modules.cpp
+++ b/clang/test/Modules/type-aware-destroying-new-and-delete-modules.cpp
@@ -0,0 +1,23 @@
+// RUN: rm -rf %t
+// RUN: %clang_cc1 -fmodules -fimplicit-module-maps -x c++ -std=c++26 -fmodules-cache-path=%t -I %S/Inputs/PR137102 -emit-llvm-only %s
+// RUN: %clang_cc1 -fmodules -fimplicit-module-maps -x c++ -std=c++26 -fmodules-cache-path=%t -I %S/Inputs/PR137102 -emit-llvm-only %s -triple i686-windows
+
+#include "type_aware_destroying_new_delete.h"
+
+
+static void call_in_module_function(void) {
+    in_module_tests();
+}
+
+void out_of_module_tests() {
+    A* a = new A;
+    delete a;
+    B *b = new B;
+    delete b;
+    C *c = new C;
+    delete c;
+    D *d = new D;
+    delete d;
+    E *e = new E;
+    delete e;
+}
diff -ruN --strip-trailing-cr a/clang/test/PCH/Inputs/type_aware_destroying_new_delete.h b/clang/test/PCH/Inputs/type_aware_destroying_new_delete.h
--- a/clang/test/PCH/Inputs/type_aware_destroying_new_delete.h
+++ b/clang/test/PCH/Inputs/type_aware_destroying_new_delete.h
@@ -0,0 +1,52 @@
+
+namespace std {
+    struct destroying_delete_t { };
+    template <class T> struct type_identity {
+        using type = T;
+    };
+    typedef __SIZE_TYPE__ size_t;
+    enum class align_val_t : size_t;
+};
+
+struct A {
+    A();
+   void *operator new(std::size_t);
+   void operator delete(A*, std::destroying_delete_t);
+};
+
+struct B {
+    B();
+    void *operator new(std::type_identity<B>, std::size_t, std::align_val_t);
+    void operator delete(std::type_identity<B>, void*, std::size_t, std::align_val_t);
+};
+
+struct C {
+    C();
+    template <class T> void *operator new(std::type_identity<T>, std::size_t, std::align_val_t);
+    template <class T> void operator delete(std::type_identity<T>, void*, std::size_t, std::align_val_t);
+};
+
+struct D {
+    D();
+};
+void *operator new(std::type_identity<D>, std::size_t, std::align_val_t);
+void operator delete(std::type_identity<D>, void*, std::size_t, std::align_val_t);
+
+struct E {
+    E();
+};
+template <class T> void *operator new(std::type_identity<T>, std::size_t, std::align_val_t);
+template <class T> void operator delete(std::type_identity<T>, void*, std::size_t, std::align_val_t);
+
+void in_pch_tests() {
+  A* a = new A;
+  delete a;
+  B *b = new B;
+  delete b;
+  C *c = new C;
+  delete c;
+  D *d = new D;
+  delete d;
+  E *e = new E;
+  delete e;
+}
diff -ruN --strip-trailing-cr a/clang/test/PCH/type-aware-destroying-new-and-delete-pch.cpp b/clang/test/PCH/type-aware-destroying-new-and-delete-pch.cpp
--- a/clang/test/PCH/type-aware-destroying-new-and-delete-pch.cpp
+++ b/clang/test/PCH/type-aware-destroying-new-and-delete-pch.cpp
@@ -0,0 +1,27 @@
+// Test this without pch.
+// RUN: %clang_cc1 -x c++ -std=c++26 -include %S/Inputs/type_aware_destroying_new_delete.h -emit-llvm -o - %s
+
+// Test with pch.
+// RUN: %clang_cc1 -x c++ -std=c++26 -emit-pch -o %t %S/Inputs/type_aware_destroying_new_delete.h
+// RUN: %clang_cc1 -x c++ -std=c++26 -include-pch %t -emit-llvm -o - %s 
+
+// RUN: %clang_cc1 -x c++ -std=c++11 -emit-pch -fpch-instantiate-templates -o %t %S/Inputs/type_aware_destroying_new_delete.h
+// RUN: %clang_cc1 -x c++ -std=c++11 -include-pch %t -emit-llvm -o - %s
+
+
+static void call_in_pch_function(void) {
+    in_pch_tests();
+}
+
+void out_of_pch_tests() {
+    A* a = new A;
+    delete a;
+    B *b = new B;
+    delete b;
+    C *c = new C;
+    delete c;
+    D *d = new D;
+    delete d;
+    E *e = new E;
+    delete e;
+}
diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
@@ -23979,6 +23979,8 @@
     assert(isValidElementType(V1->getType()) &&
            isValidElementType(V2->getType()) &&
            "Expected vectorizable types only.");
+    if (V1 == V2)
+      return false;
     // It is fine to compare type IDs here, since we expect only vectorizable
     // types, like ints, floats and pointers, we don't care about other type.
     if (V1->getType()->getTypeID() < V2->getType()->getTypeID())
@@ -24015,7 +24017,7 @@
           if (NodeI1 != NodeI2)
             return NodeI1->getDFSNumIn() < NodeI2->getDFSNumIn();
           InstructionsState S = getSameOpcode({I1, I2}, *TLI);
-          if (S && !S.isAltShuffle()) {
+          if (S && !S.isAltShuffle() && I1->getOpcode() == I2->getOpcode()) {
             const auto *E1 = dyn_cast<ExtractElementInst>(I1);
             const auto *E2 = dyn_cast<ExtractElementInst>(I2);
             if (!E1 || !E2)
@@ -24047,6 +24049,8 @@
 
             continue;
           }
+          if (I1->getOpcode() == I2->getOpcode())
+            continue;
           return I1->getOpcode() < I2->getOpcode();
         }
         if (I1)
diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/phi-comparator.ll b/llvm/test/Transforms/SLPVectorizer/X86/phi-comparator.ll
--- a/llvm/test/Transforms/SLPVectorizer/X86/phi-comparator.ll
+++ b/llvm/test/Transforms/SLPVectorizer/X86/phi-comparator.ll
@@ -0,0 +1,38 @@
+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
+; RUN: opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu < %s | FileCheck %s
+
+define void @test(i32 %julianDay, i1 %cmp, i8 %0, i16 %1) {
+; CHECK-LABEL: define void @test(
+; CHECK-SAME: i32 [[JULIANDAY:%.*]], i1 [[CMP:%.*]], i8 [[TMP0:%.*]], i16 [[TMP1:%.*]]) {
+; CHECK-NEXT:  [[ENTRY:.*]]:
+; CHECK-NEXT:    br i1 [[CMP]], label %[[IF_THEN2:.*]], label %[[IF_END33:.*]]
+; CHECK:       [[IF_THEN2]]:
+; CHECK-NEXT:    [[CONV_I:%.*]] = sext i8 [[TMP0]] to i32
+; CHECK-NEXT:    [[CONV_I2:%.*]] = sext i16 [[TMP1]] to i32
+; CHECK-NEXT:    br label %[[IF_END33]]
+; CHECK:       [[IF_END33]]:
+; CHECK-NEXT:    [[MONTH_0:%.*]] = phi i32 [ [[CONV_I]], %[[IF_THEN2]] ], [ 0, %[[ENTRY]] ]
+; CHECK-NEXT:    [[DAYOFMONTH_0:%.*]] = phi i32 [ [[CONV_I]], %[[IF_THEN2]] ], [ [[JULIANDAY]], %[[ENTRY]] ]
+; CHECK-NEXT:    [[DAYOFYEAR_0:%.*]] = phi i32 [ [[CONV_I2]], %[[IF_THEN2]] ], [ 0, %[[ENTRY]] ]
+; CHECK-NEXT:    store volatile i32 [[MONTH_0]], ptr null, align 4294967296
+; CHECK-NEXT:    store volatile i32 [[DAYOFMONTH_0]], ptr null, align 4294967296
+; CHECK-NEXT:    store volatile i32 [[DAYOFYEAR_0]], ptr null, align 4294967296
+; CHECK-NEXT:    ret void
+;
+entry:
+  br i1 %cmp, label %if.then2, label %if.end33
+
+if.then2:
+  %conv.i = sext i8 %0 to i32
+  %conv.i2 = sext i16 %1 to i32
+  br label %if.end33
+
+if.end33:
+  %month.0 = phi i32 [ %conv.i, %if.then2 ], [ 0, %entry ]
+  %dayOfMonth.0 = phi i32 [ %conv.i, %if.then2 ], [ %julianDay, %entry ]
+  %dayOfYear.0 = phi i32 [ %conv.i2, %if.then2 ], [ 0, %entry ]
+  store volatile i32 %month.0, ptr null, align 4294967296
+  store volatile i32 %dayOfMonth.0, ptr null, align 4294967296
+  store volatile i32 %dayOfYear.0, ptr null, align 4294967296
+  ret void
+}
